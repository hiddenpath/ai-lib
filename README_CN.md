# âš ï¸ é‡è¦å…¬å‘Šï¼šæœ¬ä»“åº“å·²åœæ­¢æ›´æ–°

> **æœ¬ä»“åº“ï¼ˆai-libï¼‰å·²åœæ­¢ç»´æŠ¤ï¼Œä¸å†æ¥å—æ–°çš„ PRã€Issue æˆ–åŠŸèƒ½æ›´æ–°ã€‚**

## ğŸš€ è¿ç§»åˆ° ai-lib-rust

**ai-lib é¡¹ç›®å·²å®Œå…¨è½¬å‘ [ai-lib-rust](https://github.com/hiddenpath/ai-lib-rust)**ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¨æ–°çš„ã€åŸºäº **manifest-firstï¼ˆåè®®ä¼˜å…ˆï¼‰** å’Œ **æ•°æ®é©±åŠ¨** æ¶æ„çš„é€šç”¨ AI æ¥å£è¿è¡Œæ—¶ã€‚

### ä¸ºä»€ä¹ˆè¿ç§»ï¼Ÿ

- âœ… **åè®®é©±åŠ¨æ¶æ„**: æ‰€æœ‰é€»è¾‘ç”± YAML åè®®æ–‡ä»¶é©±åŠ¨ï¼Œæ— éœ€ç¡¬ç¼–ç  provider é€»è¾‘
- âœ… **ç»Ÿä¸€æ ‡å‡†**: åŸºäº [AI-Protocol](https://github.com/hiddenpath/ai-protocol) è§„èŒƒï¼Œç¡®ä¿è·¨è¿è¡Œæ—¶ä¸€è‡´æ€§
- âœ… **æ›´ç®€æ´çš„ API**: å¼€å‘è€…å‹å¥½çš„æ¥å£ï¼Œé¿å…å¤æ‚æ··ä¹±çš„ç”¨æˆ·ç•Œé¢
- âœ… **æ›´å¥½çš„å¯ç»´æŠ¤æ€§**: æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¸…æ™°çš„æ¶æ„åˆ†å±‚
- âœ… **ç”Ÿäº§å°±ç»ª**: å®Œæ•´çš„æµ‹è¯•è¦†ç›–ã€CI/CD é›†æˆã€åè®®éªŒè¯

### å¦‚ä½•è¿ç§»ï¼Ÿ

1. **æŸ¥çœ‹æ–°é¡¹ç›®**: [ai-lib-rust](https://github.com/hiddenpath/ai-lib-rust)
2. **æŸ¥çœ‹åè®®è§„èŒƒ**: [AI-Protocol](https://github.com/hiddenpath/ai-protocol)
3. **è¿ç§»æŒ‡å—**: è¯·å‚è€ƒ ai-lib-rust çš„ README å’Œç¤ºä¾‹ä»£ç ï¼Œæˆ–æŸ¥çœ‹ [MIGRATION_GUIDE.md](./MIGRATION_GUIDE.md)

### è·å–å¸®åŠ©

- **æ–°é¡¹ç›® Issues**: [ai-lib-rust Issues](https://github.com/hiddenpath/ai-lib-rust/issues)
- **åè®®è§„èŒƒ**: [AI-Protocol](https://github.com/hiddenpath/ai-protocol)
- **è®¨è®º**: è¯·åœ¨ ai-lib-rust ä»“åº“ä¸­æå‡ºé—®é¢˜å’Œå»ºè®®

---

# ai-lib ğŸ¦€âœ¨ (å·²åœæ­¢ç»´æŠ¤)

> é¢å‘ Rust çš„ç»Ÿä¸€ã€å¯é ã€é«˜æ€§èƒ½å¤šå‚å•† AI SDK

**âš ï¸ æ³¨æ„**: æœ¬ä»“åº“å·²åœæ­¢æ›´æ–°ã€‚è¯·è¿ç§»åˆ° [ai-lib-rust](https://github.com/hiddenpath/ai-lib-rust)ã€‚

ä¸€ä¸ªç”Ÿäº§çº§ã€å‚å•†æ— å…³çš„ SDKï¼Œæä¾›é¢å‘ 20+ å®¶ä¸”æŒç»­å¢åŠ  çš„ AI å¹³å°çš„ç»Ÿä¸€ Rust APIï¼ˆOpenAIã€Groqã€Anthropicã€Geminiã€Mistralã€Cohereã€Azure OpenAIã€Ollamaã€DeepSeekã€Qwenã€ç™¾åº¦æ–‡å¿ƒã€è…¾è®¯æ··å…ƒã€è®¯é£æ˜Ÿç«ã€Kimiã€HuggingFaceã€TogetherAIã€xAI Grokã€OpenRouterã€Replicateã€Perplexityã€AI21ã€æ™ºè°±AIã€MiniMax ç­‰ï¼‰ã€‚  
å®ƒæ¶ˆé™¤äº†åˆ†æ•£çš„è®¤è¯æµç¨‹ã€æµå¼æ ¼å¼ã€é”™è¯¯è¯­ä¹‰ã€æ¨¡å‹å‘½åå·®å¼‚å’Œä¸ä¸€è‡´çš„å‡½æ•°è°ƒç”¨ã€‚æ— éœ€é‡å†™é›†æˆä»£ç ï¼Œå³å¯ä»ä¸€è¡Œè„šæœ¬æ‰©å±•åˆ°ç”Ÿäº§ç³»ç»Ÿã€‚

---
[å®˜æ–¹ç½‘ç«™](https://www.ailib.info/)

## ğŸš€ æ ¸å¿ƒä»·å€¼

ai-lib å°†å¤šå®¶ AI å‚å•†çš„å¤æ‚æ€§ç»Ÿä¸€ä¸ºä¸€ä¸ªç®€æ´çš„äººä½“å·¥å­¦ Rust æ¥å£ï¼š

- **é€šç”¨ API**ï¼šåœ¨æ‰€æœ‰å‚å•†ä¸Šç»Ÿä¸€çš„èŠå¤©ã€å¤šæ¨¡æ€ä¸å‡½æ•°è°ƒç”¨
- **å¤šæ¨¡æ€å†…å®¹**ï¼šä¾¿æ·çš„å›¾åƒå’ŒéŸ³é¢‘å†…å®¹åˆ›å»ºï¼Œæ”¯æŒ `Content::from_image_file()` å’Œ `Content::from_audio_file()`
- **ç»Ÿä¸€æµå¼**ï¼šä¸€è‡´çš„ SSE/JSONL è§£æä¸å®æ—¶å¢é‡
- **å¯é æ€§**ï¼šå†…ç½®é‡è¯•ã€è¶…æ—¶ã€ç†”æ–­ä¸é”™è¯¯åˆ†ç±»
- **çµæ´»é…ç½®**ï¼šç¯å¢ƒå˜é‡ã€Builder æ¨¡å¼æˆ–æ˜¾å¼è¦†ç›–
- **ç”Ÿäº§å°±ç»ª**ï¼šè¿æ¥æ± ã€ä»£ç†æ”¯æŒã€å¯è§‚æµ‹æ€§é’©å­

**ç»“æœ**ï¼šä½ ä¸“æ³¨äº§å“é€»è¾‘ï¼Œai-lib å¤„ç†ä¾›åº”å•†é›†æˆçš„ç¹çå·¥ä½œã€‚

> å¯¼å…¥å»ºè®®ï¼šåº”ç”¨å±‚ä¼˜å…ˆä½¿ç”¨ `use ai_lib::prelude::*;` è·å–æœ€å°å¸¸ç”¨é›†ï¼›åº“ä½œè€…å»ºè®®æŒ‰é¢†åŸŸæ˜¾å¼å¯¼å…¥ã€‚å‚è§æ¨¡å—æ ‘ä¸å¯¼å…¥æ¨¡å¼æŒ‡å—ï¼š`docs/MODULE_TREE_AND_IMPORTS.md`ã€‚

## âš™ï¸ å¿«é€Ÿå¼€å§‹

### å®‰è£…

åŸºç¡€å®‰è£…ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰ï¼š
```toml
[dependencies]
ai-lib = "0.4.0"
tokio = { version = "1", features = ["full"] }
futures = "0.3"
```

å¯ç”¨æµå¼æ”¯æŒï¼š
```toml
[dependencies]
ai-lib = { version = "0.4.0", features = ["streaming"] }
tokio = { version = "1", features = ["full"] }
futures = "0.3"
```

å®Œæ•´åŠŸèƒ½ï¼ˆæµå¼ã€å¼¹æ€§ã€è·¯ç”±ï¼‰ï¼š
```toml
[dependencies]
ai-lib = { version = "0.4.0", features = ["all"] }
tokio = { version = "1", features = ["full"] }
futures = "0.3"
```

### ç®€å•ç”¨æ³•
```rust
use ai_lib::prelude::*;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = AiClient::new(Provider::Groq)?;
    let req = ChatCompletionRequest::new(
        "llama3-8b-8192".to_string(),
        vec![Message::user("Hello!")]
    );
    let reply = client.chat_completion(req).await?;
    println!("Reply: {}", reply.first_text().unwrap_or_default());
    Ok(())
}
```

### æ ‡å‡†ç”¨æ³•
```rust
// åº”ç”¨å±‚å¯ä»¥ä½¿ç”¨ prelude æ¥æœ€å°åŒ–å¯¼å…¥
use ai_lib::prelude::*;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = AiClient::new(Provider::OpenAI)?;
    let req = ChatCompletionRequest::new(
        "gpt-3.5-turbo".to_string(), // æ˜¾å¼æ¨¡å‹æˆ–ä½¿ç”¨ client.default_chat_model()
        vec![Message {
            role: Role::User,
            content: Content::Text("Explain Rust ownership in one sentence.".to_string()),
            function_call: None,
        }],
    );
    // .with_extension("parallel_tool_calls", serde_json::json!(true)); // å¯é€‰æ‰©å±•

    let resp = client.chat_completion(req).await?;
    println!("Answer: {}", resp.choices[0].message.content.as_text());
    Ok(())
}
```

### æµå¼èŠå¤©

> **æ³¨æ„ï¼š** æµå¼åŠŸèƒ½éœ€è¦å¯ç”¨ `streaming` ç‰¹æ€§ï¼ˆæˆ– `all` ç‰¹æ€§ï¼‰ã€‚

```rust
use ai_lib::prelude::*;
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let client = AiClient::new(Provider::OpenAI)?;
    let req = ChatCompletionRequest::new(
        "gpt-3.5-turbo".to_string(),
        vec![Message::user("Tell me a short story")]
    );

    let mut stream = client.chat_completion_stream(req).await?;
    while let Some(chunk) = stream.next().await {
        let c = chunk?;
        if let Some(delta) = c.choices.get(0).and_then(|ch| ch.delta.content.clone()) {
            print!("{delta}");
        }
    }
    Ok(())
}
```

---

## ğŸ§  æ ¸å¿ƒæ¦‚å¿µ

| æ¦‚å¿µ | ç›®çš„ |
|--------|---------|
| **Provider** | æšä¸¾æ‰€æœ‰æ”¯æŒçš„ AI å‚å•† |
| **AiClient** | ç»Ÿä¸€æ¥å£çš„ä¸»å…¥å£ |
| **ChatCompletionRequest** | æ ‡å‡†åŒ–çš„è¯·æ±‚è½½è· |
| **Message / Content** | æ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ç­‰å†…å®¹ç±»å‹ |
| **Streaming Event** | å‚å•†æ ‡å‡†åŒ–çš„å¢é‡æµ |
| **ConnectionOptions** | è¿è¡Œæ—¶é…ç½®è¦†ç›– |
| **Metrics Trait** | è‡ªå®šä¹‰å¯è§‚æµ‹æ€§é›†æˆ |
| **Transport** | å¯æ³¨å…¥çš„ HTTP + æµå¼å±‚ |
| **Usage / UsageStatus** | å“åº”çº§ä½¿ç”¨é‡å…ƒæ•°æ®ï¼ˆä»¤ç‰Œ + çŠ¶æ€ï¼‰ã€‚ä» `ai_lib::Usage` æˆ– `ai_lib::types::response::Usage` å¯¼å…¥ |

---

## ğŸ’¡ å…³é”®ç‰¹æ€§

### æ ¸å¿ƒèƒ½åŠ›
- **ç»Ÿä¸€å‚å•†æŠ½è±¡**ï¼šè·¨æ‰€æœ‰å‚å•†çš„å•ä¸€ API
- **ç»Ÿä¸€æµå¼ä¼ è¾“**ï¼šä¸€è‡´çš„ SSE/JSONL è§£æä¸å®æ—¶å¢é‡
- **å¤šæ¨¡æ€æ”¯æŒ**ï¼šæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘å†…å®¹å¤„ç†
- **å‡½æ•°è°ƒç”¨**ï¼šä¸€è‡´çš„å·¥å…·æ¨¡å¼ï¼Œå…¼å®¹ OpenAI
- **æ‰¹å¤„ç†**ï¼šé¡ºåºå’Œå¹¶å‘å¤„ç†ç­–ç•¥

### å¯é æ€§ä¸ç”Ÿäº§
- **å†…ç½®å¼¹æ€§**ï¼šæŒ‡æ•°é€€é¿é‡è¯•ã€ç†”æ–­å™¨
- **ç­–ç•¥æ„å»ºå™¨**ï¼š`AiClientBuilder::with_round_robin_chain` / `with_failover_chain` åœ¨è¿è¡Œå‰ç»„åˆè·¯ç”±ç­–ç•¥
- **é”™è¯¯åˆ†ç±»**ï¼šåŒºåˆ†ç¬æ€ä¸æ°¸ä¹…å¤±è´¥
- **è¿æ¥ç®¡ç†**ï¼šæ± åŒ–ã€è¶…æ—¶ã€ä»£ç†æ”¯æŒ
- **å¯è§‚æµ‹æ€§**ï¼šå¯æ’æ‹”æŒ‡æ ‡ä¸è¿½è¸ªé›†æˆ
- **å®‰å…¨**ï¼šé»˜è®¤ä¸è®°å½•æ•æ„Ÿå†…å®¹

---

## ğŸŒ æ”¯æŒçš„å‚å•†

*17+ å®¶ä¸”æŒç»­å¢åŠ * â€”â€” æˆ‘ä»¬æŒç»­æ–°å¢å¹³å°ä»¥é€‚é…æ¼”è¿›ä¸­çš„ç”Ÿæ€ã€‚

| å‚å•† | æµå¼ | ç‰¹ç‚¹ |
|----------|-----------|------------|
| **Groq** | âœ… | è¶…ä½å»¶è¿Ÿæ¨ç† |
| **OpenAI** | âœ… | GPT æ¨¡å‹ï¼Œå‡½æ•°è°ƒç”¨ |
| **Anthropic** | âœ… | Claude æ¨¡å‹ï¼Œé«˜è´¨é‡ |
| **Google Gemini** | âœ… | å¤šæ¨¡æ€èƒ½åŠ› |
| **Mistral** | âœ… | æ¬§æ´²æ¨¡å‹ |
| **Cohere** | âœ… | RAG ä¼˜åŒ– |
| **HuggingFace** | âœ… | å¼€æºæ¨¡å‹ |
| **TogetherAI** | âœ… | æˆæœ¬æ•ˆç›Šæ¨ç† |
| **OpenRouter** | âœ… | ç»Ÿä¸€ç½‘å…³ï¼Œå¤šå‚å•†æ¨¡å‹è·¯ç”± |
| **Replicate** | âœ… | æ‰˜ç®¡å¼€æºæ¨¡å‹ |
| **DeepSeek** | âœ… | æ¨ç†å¯¼å‘æ¨¡å‹ |
| **Qwen** | âœ… | ä¸­æ–‡ç”Ÿæ€ |
| **ç™¾åº¦æ–‡å¿ƒ** | âœ… | ä¼ä¸šçº§ä¸­å›½å¸‚åœº |
| **è…¾è®¯æ··å…ƒ** | âœ… | äº‘é›†æˆ |
| **è®¯é£æ˜Ÿç«** | âœ… | è¯­éŸ³ + å¤šæ¨¡æ€ |
| **æœˆä¹‹æš—é¢Kimi** | âœ… | é•¿ä¸Šä¸‹æ–‡æ¨¡å‹ |
| **Azure OpenAI** | âœ… | ä¼ä¸šåˆè§„ |
| **Ollama** | âœ… | æœ¬åœ°/éš”ç¦»éƒ¨ç½² |
| **xAI Grok** | âœ… | å®æ—¶å¯¼å‘ |
| **Perplexity** | âœ… | æœç´¢å¢å¼ºå¯¹è¯ |
| **AI21** | âœ… | Jurassic æ¨¡å‹ |
| **æ™ºè°±AI (GLM)** | âœ… | ä¸­å›½ GLM ç³»åˆ— |
| **MiniMax** | âœ… | ä¸­å›½å¤šæ¨¡æ€ |

*å‚è§ [examples/](examples/) è·å–å‚å•†ç‰¹å®šä½¿ç”¨æ¨¡å¼ã€‚*

### ç½‘å…³å‹æä¾›å•†
ai-lib æ”¯æŒ OpenRouterã€Replicate ç­‰ç½‘å…³å‹æä¾›å•†ï¼Œé€šè¿‡ç»Ÿä¸€æ¥å£è®¿é—®å¤šä¸ª AI æ¨¡å‹ã€‚ç½‘å…³å¹³å°ä½¿ç”¨ `provider/model` æ ¼å¼çš„æ¨¡å‹å‘½åï¼ˆå¦‚ `openai/gpt-4o`ï¼‰ï¼Œè€Œç›´æ¥æä¾›å•†ä½¿ç”¨åŸå§‹æ¨¡å‹åï¼ˆå¦‚ `gpt-4o`ï¼‰ã€‚

---

## ğŸ”‘ é…ç½®

### ç¯å¢ƒå˜é‡
```bash
# API Keysï¼ˆçº¦å®šï¼‰
export OPENAI_API_KEY=...
export GROQ_API_KEY=...
export GEMINI_API_KEY=...
export ANTHROPIC_API_KEY=...
export OPENROUTER_API_KEY=...
export REPLICATE_API_TOKEN=...
export PERPLEXITY_API_KEY=...
export AI21_API_KEY=...
export ZHIPU_API_KEY=...
export MINIMAX_API_KEY=...

# å¯é€‰ï¼šè‡ªå®šä¹‰ Endpoint
export GROQ_BASE_URL=https://custom.groq.com

# å¯é€‰ï¼šä»£ç†ä¸è¶…æ—¶
export AI_PROXY_URL=http://proxy.internal:8080
export AI_TIMEOUT_SECS=30

# å¯é€‰ï¼šè¿æ¥æ± ï¼ˆé»˜è®¤å¯ç”¨ï¼‰
export AI_HTTP_POOL_MAX_IDLE_PER_HOST=32
export AI_HTTP_POOL_IDLE_TIMEOUT_MS=90000

# å¯é€‰ï¼šæŒ‰å‚å•†è¦†ç›–é»˜è®¤æ¨¡å‹
export GROQ_MODEL=llama-3.1-8b-instant
export MISTRAL_MODEL=mistral-small-latest
export DEFAULT_AI_MODEL=gpt-4o-mini
```

### æ¨¡å‹é€‰æ‹©ä¸å…œåº•

- **è‡ªåŠ¨é»˜è®¤å€¼**ï¼šæ„é€  `ChatCompletionRequest` æ—¶å°† `model` è®¾ä¸º `"auto"`ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
  æˆ–ç©ºå­—ç¬¦ä¸²ï¼Œai-lib ä¼šè‡ªåŠ¨æ³¨å…¥è¯¥ Provider çš„æ¨èæ¨¡å‹ï¼Œæˆ–é‡‡ç”¨
  `AiClientBuilder::with_default_chat_model` çš„è‡ªå®šä¹‰å€¼ã€‚
- **ç¯å¢ƒå˜é‡è¦†ç›–**ï¼šé€šè¿‡ `*_MODEL` ç¯å¢ƒå˜é‡ï¼ˆå¦‚ `GROQ_MODEL`ã€`OPENAI_MODEL`ï¼‰å³å¯
  åœ¨ä¸æ”¹ä»£ç çš„å‰æä¸‹åˆ‡æ¢é»˜è®¤æ¨¡å‹ã€‚è¿™äº›å˜é‡ç”±æ–°çš„ `ModelResolver` ç»Ÿä¸€è¯»å–ï¼Œ
  å¯¹æ™®é€šè°ƒç”¨ã€æµå¼å’Œæ‰¹å¤„ç†å‡ç”Ÿæ•ˆã€‚
- **æ— æ•ˆæ¨¡å‹æ¢å¤**ï¼šå½“åç«¯è¿”å› `invalid_model/model_not_found` æ—¶ï¼Œai-lib ä¼šè‡ªåŠ¨
  å°è¯•é…ç½®ä¸­çš„å¤‡é€‰æ¨¡å‹ï¼Œå¹¶åœ¨æœ€ç»ˆçš„ `AiLibError::ModelNotFound` ä¸­é™„å¸¦å¯æ“ä½œæç¤º
  ä¸æ–‡æ¡£é“¾æ¥ï¼ˆä¾‹å¦‚ [Groq æ¨¡å‹åˆ—è¡¨](https://console.groq.com/docs/models)ï¼‰ã€‚
- **è¿è¡Œæ—¶å¯è§æ€§**ï¼šè°ƒç”¨ `client.default_chat_model()` å¯ä»¥æŸ¥è¯¢å½“å‰å®é™…ä½¿ç”¨çš„æ¨¡å‹ï¼Œ
  ä¾¿äºè°ƒè¯•å¤š Provider failover/round-robin çš„åœºæ™¯ã€‚

### ç¨‹åºåŒ–é…ç½®
```rust
use ai_lib::{AiClient, Provider, ConnectionOptions};
use std::time::Duration;

let client = AiClient::with_options(
    Provider::Groq,
    ConnectionOptions {
        base_url: Some("https://custom.groq.com".into()),
        proxy: Some("http://proxy.internal:8080".into()),
        api_key: Some("override-key".into()),
        timeout: Some(Duration::from_secs(45)),
        disable_proxy: false,
    }
)?;
```

## ğŸ”Œ è‡ªå®šä¹‰æä¾›å•†

ä½¿ç”¨ `CustomProviderBuilder` + `AiClientBuilder::with_strategy` å¯ä»¥åœ¨ä¸ä¿®æ”¹ `Provider` æšä¸¾çš„æƒ…å†µä¸‹æ¥å…¥ OpenAI å…¼å®¹çš„è‡ªå»ºç½‘å…³æˆ–å‚å•†é¢„è§ˆç‰ˆã€‚å®Œæ•´ç¤ºä¾‹å‚è§ `examples/custom_provider_injection.rs`ã€‚

```rust
use ai_lib::{
    client::{AiClientBuilder, Provider},
    provider::builders::CustomProviderBuilder,
    types::{ChatCompletionRequest, Message, Role, Content},
};

let labs_gateway = CustomProviderBuilder::new("labs-gateway")
    .with_base_url("https://labs.example.com/v1")
    .with_api_key_env("LABS_GATEWAY_TOKEN")
    .with_default_chat_model("labs-gpt-35")
    .build_provider()?;

let client = AiClientBuilder::new(Provider::OpenAI) // ç­–ç•¥æä¾›æ—¶æšä¸¾è¢«å¿½ç•¥
    .with_strategy(labs_gateway)
    .build()?;

let resp = client
    .chat_completion(ChatCompletionRequest::new(
        "labs-gpt-35".to_string(),
        vec![Message {
            role: Role::User,
            content: Content::Text("Hello labs!".to_string()),
            function_call: None,
        }],
    ))
    .await?;
println!("labs> {}", resp.first_text().unwrap_or_default());
```

### å‚å•†ä¸“å± Builder

æ¯ä¸ª Provider éƒ½å¯¹åº”ä¸€ä¸ªä¸“å± Builderï¼ˆä¾‹å¦‚ `GroqBuilder`ã€`OpenAiBuilder`ï¼‰ï¼Œç”¨äºæ›´æ¸…æ™°åœ°é…ç½®å‚æ•°æˆ–åœ¨ç»„åˆè·¯ç”±ç­–ç•¥æ—¶å¤ç”¨ã€‚

```rust
use ai_lib::provider::GroqBuilder;

let client = GroqBuilder::new()
    .with_base_url("https://api.groq.com")
    .with_proxy(Some("http://proxy.internal:8080"))
    .build()?; // è¿”å› AiClient
```

### å¹¶å‘æ§åˆ¶
```rust
use ai_lib::{AiClientBuilder, Provider};

let client = AiClientBuilder::new(Provider::Groq)
    .with_max_concurrency(64)
    .for_production()
    .build()?;
```

---

## ğŸ” è·¯ç”±ä¸æ•…éšœè½¬ç§»ï¼ˆOSSï¼‰

ä½¿ç”¨ `with_failover_chain` æˆ– `with_round_robin_chain` åœ¨å‘é€è¯·æ±‚å‰æ„å»ºè·¯ç”±ç­–ç•¥ã€‚

```rust
use ai_lib::{client::AiClientBuilder, Provider};

let client = AiClientBuilder::new(Provider::OpenAI)
    .with_failover_chain(vec![Provider::Anthropic, Provider::Groq])?
    .build()?;
```

ç»“åˆ `with_round_robin_chain` æˆ– `RoutingStrategyBuilder` å®ç°åŠ æƒ/è½®è¯¢è·¯ç”±ã€‚ç­–ç•¥ç»„åˆç°åœ¨åœ¨å®¢æˆ·ç«¯æ„å»ºæ—¶å®Œæˆï¼Œæ— éœ€è¿è¡Œæ—¶åˆ†æ”¯æˆ–å“¨å…µæ¨¡å‹ã€‚

## ğŸ›¡ï¸ å¯é æ€§ä¸å¼¹æ€§

| ç‰¹æ€§ | æè¿° |
|---------|-------------|
| **é‡è¯•é€»è¾‘** | æŒ‡æ•°é€€é¿ + æ™ºèƒ½é”™è¯¯åˆ†ç±» |
| **é”™è¯¯å¤„ç†** | åŒºåˆ†ç¬æ€ä¸æ°¸ä¹…å¤±è´¥ |
| **è¶…æ—¶** | æ”¯æŒæŒ‰è¯·æ±‚ä¸å…¨å±€è¶…æ—¶ |
| **ä»£ç†** | å…¨å±€/æŒ‰è¿æ¥/ç¦ç”¨ |
| **è¿æ¥æ± ** | å¯è°ƒæ± å¤§å°ä¸è¿æ¥ç”Ÿå‘½å‘¨æœŸ |
| **å¥åº·æ£€æŸ¥** | ç«¯ç‚¹ç›‘æ§ä¸ç­–ç•¥åŒ–é€‰æ‹© |
| **å›é€€ç­–ç•¥** | å¤šå‚å•†æ•°ç»„ä¸æ‰‹åŠ¨æ•…éšœåˆ‡æ¢ |

---

## ğŸ“Š å¯è§‚æµ‹æ€§ä¸æŒ‡æ ‡

### è‡ªå®šä¹‰æŒ‡æ ‡é›†æˆ
```rust
struct CustomMetrics;
#[async_trait::async_trait]
impl ai_lib::metrics::Metrics for CustomMetrics {
    async fn incr_counter(&self, name: &str, value: u64) { /* ... */ }
    async fn start_timer(&self, name: &str) -> Option<Box<dyn ai_lib::metrics::Timer + Send>> { /* ... */ }
}
let client = AiClient::new_with_metrics(Provider::Groq, Arc::new(CustomMetrics))?;
```

### ç”¨é‡è·Ÿè¸ª
```rust
match response.usage_status {
    UsageStatus::Finalized => println!("å‡†ç¡®ä»¤ç‰Œè®¡æ•°: {:?}", response.usage),
    UsageStatus::Estimated => println!("ä¼°ç®—ä»¤ç‰Œ: {:?}", response.usage),
    UsageStatus::Pending => println!("ä½¿ç”¨é‡æ•°æ®å°šæœªå¯ç”¨"),
    UsageStatus::Unsupported => println!("å‚å•†ä¸æ”¯æŒä½¿ç”¨é‡è·Ÿè¸ª"),
}
```
è¿ç§»ï¼š`Usage`/`UsageStatus` å®šä¹‰åœ¨ `ai_lib::types::response` ä¸­ï¼Œä½œä¸ºæ ¹çº§åˆ«çš„ re-exportã€‚åœ¨ 1.0 ç‰ˆæœ¬å‰ï¼Œä» `types::common` çš„æ—§å¯¼å…¥å°†è¢«ç§»é™¤ã€‚

### å¯é€‰ç‰¹æ€§

é»˜è®¤æƒ…å†µä¸‹ï¼Œai-lib ä»…å¯ç”¨æœ€å°åŠŸèƒ½é›†ã€‚æ ¹æ®éœ€è¦å¯ç”¨ç‰¹æ€§ï¼š

| ç‰¹æ€§ | æè¿° | åˆ«å |
|---------|-------------|-------|
| `unified_sse` | æµå¼ä¼ è¾“çš„é€šç”¨ SSE è§£æå™¨ | `streaming` |
| `interceptors` | é‡è¯•ã€è¶…æ—¶ã€ç†”æ–­å™¨ç®¡é“ | `resilience` |
| `unified_transport` | å…±äº« HTTP å®¢æˆ·ç«¯å·¥å‚ | `transport` |
| `config_hot_reload` | é…ç½®çƒ­é‡è½½ trait | `hot_reload` |
| `cost_metrics` | åŸºäºç¯å¢ƒå˜é‡çš„åŸºç¡€æˆæœ¬æ ¸ç®— | - |
| `routing_mvp` | æ¨¡å‹é€‰æ‹©ä¸è·¯ç”±åŠŸèƒ½ | - |
| `observability` | Tracer å’Œ AuditSink æ¥å£ | - |
| `all` | å¯ç”¨ä¸Šè¿°æ‰€æœ‰ç‰¹æ€§ | - |

**å¤§å¤šæ•°åº”ç”¨æ¨èé…ç½®ï¼š**
```toml
ai-lib = { version = "0.4.0", features = ["streaming", "resilience"] }
```

---

## ğŸ—‚ï¸ ç¤ºä¾‹

| ç±»åˆ« | ç¤ºä¾‹ |
|----------|----------|
| **å…¥é—¨** | `quickstart`, `basic_usage`, `builder_pattern` |
| **é…ç½®** | `explicit_config`, `proxy_example`, `custom_transport_config` |
| **æµå¼ä¼ è¾“** | `test_streaming`, `cohere_stream` |
| **å¯é æ€§** | `custom_transport`, `resilience_example` |
| **å¤šå‚å•†** | `config_driven_example`, `model_override_demo`, `custom_provider_injection`, `routing_modelarray` |
| **æ¨¡å‹ç®¡ç†** | `model_management`, `routing_modelarray` |
| **æ‰¹å¤„ç†** | `batch_processing` |
| **å‡½æ•°è°ƒç”¨** | `function_call_openai`, `function_call_exec` |
| **å¤šæ¨¡æ€** | `multimodal_example` |
| **é«˜çº§** | `architecture_progress`, `reasoning_best_practices` |

---

## ğŸ“„ è®¸å¯è¯

åœ¨ MIT æˆ– Apache License 2.0 ä¹‹ä¸‹åŒé‡è®¸å¯â€”â€”å¯è‡ªç”±é€‰æ‹©æ›´é€‚åˆä½ é¡¹ç›®çš„è®¸å¯ã€‚

---

## ğŸ¤ è´¡çŒ®

1. Fork å¹¶å…‹éš†ä»“åº“  
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯ï¼š`git checkout -b feature/your-feature`  
3. è¿è¡Œæµ‹è¯•ï¼š`cargo test`  
4. æ–°åŠŸèƒ½è¯·è¡¥å……ç¤ºä¾‹  
5. éµå¾ªé€‚é…å™¨æ¨¡å¼ï¼ˆä¼˜å…ˆé…ç½®é©±åŠ¨è€Œéè‡ªå®šä¹‰ï¼‰  
6. æäº¤ PR æ—¶é™„ä¸ŠåŠ¨æœºä¸ï¼ˆè‹¥æœ‰æ€§èƒ½å½±å“ï¼‰åŸºå‡†æ•°æ®  

**æˆ‘ä»¬é‡è§†**ï¼šæ¸…æ™°åº¦ã€æµ‹è¯•è¦†ç›–ã€æœ€å°è¡¨é¢ç§¯ã€å¢é‡å¯ç»„åˆæ€§ã€‚

---

## ğŸ“š å¼•ç”¨

```bibtex
@software{ai-lib,
    title = {ai-lib: A Unified AI SDK for Rust},
    author = {Luqiang Wang},
    url = {https://github.com/hiddenpath/ai-lib},
    year = {2025}
}
```

---

<div align="center">
  <strong>ai-libï¼šç”¨ Rust æ„å»ºå¼¹æ€§ã€å¿«é€Ÿã€å¤šå‚å•†çš„ AI ç³»ç»Ÿâ€”â€”å‘Šåˆ«é›†æˆç–²åŠ³ã€‚</strong><br/><br/>
  â­ å¦‚æœå®ƒå¸®ä½ èŠ‚çœäº†æ—¶é—´ï¼Œæ¬¢è¿ç‚¹äº® starï¼Œå¹¶åœ¨ Issues/Discussions ç•™è¨€åé¦ˆï¼
</div>
