2-æ ¸å¿ƒï¼šclientæ„å»ºå’Œç»Ÿä¸€æµå¼å¤„ç†

**Rust è¿è¡Œæ—¶å¦‚ä½•ä» manifest æ„å»ºå¤š endpoint çš„ clientï¼Œå¹¶å®ç°ç»Ÿä¸€çš„æµå¼å¤„ç†ï¼ˆstreamingï¼‰**ã€‚

---

# ğŸš€ Rust è¿è¡Œæ—¶ï¼šä» Client æ„å»ºåˆ°å¤š Endpoint è°ƒç”¨çš„æŠ€æœ¯è·¯å¾„

ä¸‹é¢æˆ‘ä¼šåˆ†æˆä¸‰ä¸ªéƒ¨åˆ†è®²ï¼š

1. **Client æ„å»ºä¸å¤š endpoint è·¯ç”±ï¼ˆmulti-endpoint dispatchï¼‰**  
2. **ç»Ÿä¸€çš„æµå¼å¤„ç†ï¼ˆstream abstractionï¼‰**  
3. **æ•´ä½“æ¶æ„ç¤ºæ„ï¼ˆä½ å¯ä»¥ç›´æ¥ç”¨äº ai-lib-rust runtimeï¼‰**

---

# 1. ğŸ§© Client æ„å»ºï¼šå¦‚ä½•ä» manifest åŠ¨æ€ç”Ÿæˆå¤š endpoint è°ƒç”¨èƒ½åŠ›

åœ¨ ai-protocol çš„ manifest ä¸­ï¼Œæ¯ä¸ª provider/model éƒ½å¯èƒ½æœ‰å¤šä¸ª endpointï¼Œä¾‹å¦‚ï¼š

- OpenAI: `/v1/chat/completions`, `/v1/embeddings`
- Anthropic: `/v1/messages`, `/v1/complete`
- è‡ªå»ºæ¨¡å‹: `/infer`, `/stream`

Rust è¿è¡Œæ—¶éœ€è¦åšåˆ°ï¼š

- **ä¸å†™æ­» endpoint**
- **æ ¹æ® operator è‡ªåŠ¨é€‰æ‹© endpoint**
- **æ”¯æŒ fallback / å¤š provider åˆ‡æ¢**

### âœ” æŠ€æœ¯è·¯å¾„ï¼šProvider Registry + Endpoint Router

### **Step 1ï¼šè§£æ manifest â†’ ProviderConfig**
```rust
struct ProviderConfig {
    name: String,
    base_url: String,
    endpoints: HashMap<String, EndpointConfig>, // operator -> endpoint
}
```

### **Step 2ï¼šæ„å»º ProviderClientï¼ˆåŠ¨æ€ï¼‰**
```rust
struct ProviderClient {
    http: reqwest::Client,
    config: ProviderConfig,
}
```

### **Step 3ï¼šè¿è¡Œæ—¶æ ¹æ® operator è·¯ç”±åˆ° endpoint**
```rust
impl ProviderClient {
    async fn call(&self, operator: &str, payload: Value) -> Result<Response, Error> {
        let ep = self.config.endpoints.get(operator)
            .ok_or(Error::OperatorNotSupported)?;

        let url = format!("{}/{}", self.config.base_url, ep.path);

        let req = self.http.post(&url)
            .headers(ep.headers.clone())
            .json(&payload);

        if ep.stream {
            return Ok(req.send().await?.bytes_stream());
        } else {
            return Ok(req.send().await?.json().await?);
        }
    }
}
```

### ğŸ”‘ å…³é”®ç‚¹
- endpoint æ˜¯ **manifest é©±åŠ¨**çš„ï¼Œä¸å†™æ­»
- operator â†’ endpoint çš„æ˜ å°„æ˜¯ **æ•°æ®é©±åŠ¨**çš„
- æ”¯æŒä¸åŒ provider çš„ä¸åŒ API é£æ ¼

---

# 2. ğŸŒŠ ç»Ÿä¸€æµå¼å¤„ç†ï¼šå¦‚ä½•æŠŠä¸åŒ provider çš„æµæ•´åˆæˆç»Ÿä¸€ Stream

ä¸åŒ provider çš„æµæ ¼å¼å®Œå…¨ä¸åŒï¼š

| Provider | æµæ ¼å¼ | ç‰¹ç‚¹ |
|---------|--------|------|
| OpenAI | SSE (`data: {...}`) | äº‹ä»¶æ ¼å¼ç»Ÿä¸€ |
| Anthropic | SSE + ç‰¹æ®Šå­—æ®µ | äº‹ä»¶ç±»å‹æ›´å¤š |
| è‡ªå»ºæ¨¡å‹ | chunked bytes | æ— äº‹ä»¶è¯­ä¹‰ |

ä½ éœ€è¦ä¸€ä¸ª **ç»Ÿä¸€çš„ Stream æŠ½è±¡å±‚**ã€‚

---

## âœ” æŠ€æœ¯è·¯å¾„ï¼šStreamAdapter + EventMapper

### **Step 1ï¼šåº•å±‚ä½¿ç”¨ `reqwest::Response::bytes_stream()`**
è¿™æ˜¯ä¸€ä¸ªï¼š
```rust
impl Stream<Item = Result<Bytes, reqwest::Error>>
```

### **Step 2ï¼šä¸ºæ¯ä¸ª provider å®ç° StreamAdapter**
```rust
trait StreamAdapter {
    type OutputEvent;

    fn adapt(
        &self,
        raw_stream: impl Stream<Item = Result<Bytes, Error>> + Send + 'static
    ) -> Pin<Box<dyn Stream<Item = Result<Self::OutputEvent, Error>> + Send>>;
}
```

### **Step 3ï¼šç»Ÿä¸€äº‹ä»¶æ ¼å¼ï¼ˆEventEnvelopeï¼‰**
```rust
enum EventEnvelope {
    TextDelta(String),
    Token(String),
    Error(String),
    Done,
}
```

### **Step 4ï¼šProvider-specific adapter â†’ EventEnvelope**
ä¾‹å¦‚ OpenAIï¼š
```rust
struct OpenAIStreamAdapter;

impl StreamAdapter for OpenAIStreamAdapter {
    type OutputEvent = EventEnvelope;

    fn adapt(...) -> Pin<Box<dyn Stream<Item = Result<EventEnvelope, Error>> + Send>> {
        Box::pin(raw_stream.map(|chunk| {
            let s = std::str::from_utf8(&chunk?)?;
            if s.starts_with("data: ") {
                let json = &s[6..];
                let v: Value = serde_json::from_str(json)?;
                let delta = v["choices"][0]["delta"]["content"].as_str().unwrap_or("");
                Ok(EventEnvelope::TextDelta(delta.to_string()))
            } else {
                Ok(EventEnvelope::Done)
            }
        }))
    }
}
```

Anthropicã€Ollamaã€è‡ªå»ºæ¨¡å‹éƒ½å¯ä»¥å®ç°è‡ªå·±çš„ adapterã€‚

---

# 3. ğŸ§± ç»Ÿä¸€æµå¤„ç†çš„æœ€ç»ˆæŠ½è±¡ï¼šModelStream

ä½ éœ€è¦ä¸€ä¸ªæœ€ç»ˆç»Ÿä¸€çš„æµï¼š

```rust
type ModelStream = Pin<Box<dyn Stream<Item = Result<EventEnvelope, Error>> + Send>>;
```

è¿è¡Œæ—¶è°ƒç”¨æ—¶ï¼š

```rust
let raw_stream = provider.call("generate", payload).await?;
let adapter = provider.stream_adapter();
let unified_stream = adapter.adapt(raw_stream);
return unified_stream;
```

---

# ğŸ§  æœ€ç»ˆæ¶æ„å›¾ï¼ˆç®€åŒ–ï¼‰

```
Manifest
   â†“ parse
ProviderConfig
   â†“ build
ProviderClient
   â†“ operator route
Endpoint
   â†“ call
Raw Stream (bytes)
   â†“ StreamAdapter
EventEnvelope Stream
   â†“ consumer
Unified streaming output
```

---

# ğŸ¯ æ€»ç»“ï¼šRust è¿è¡Œæ—¶çš„æ ¸å¿ƒæŠ€æœ¯è·¯å¾„

### **Client æ„å»º**
- manifest â†’ ProviderConfig
- ProviderRegistry ç®¡ç†å¤šä¸ª provider
- operator â†’ endpoint åŠ¨æ€è·¯ç”±
- æ”¯æŒ fallback / å¤š provider åˆ‡æ¢

### **ç»Ÿä¸€æµå¤„ç†**
- ä½¿ç”¨ reqwest çš„ bytes_stream ä½œä¸ºåº•å±‚
- ä¸ºæ¯ä¸ª provider å®ç° StreamAdapter
- ç»Ÿä¸€äº‹ä»¶æ ¼å¼ EventEnvelope
- æœ€ç»ˆè¾“å‡º ModelStream